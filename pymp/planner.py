import logging
import os
from typing import Sequence, Union

import numpy as np
import pinocchio as pin

from pymp.path_planning import GoalStates, JointStateSpace, RRTConnect
from pymp.robot import RobotWrapper
from pymp.utils import toSE3

logger = logging.getLogger("pymp.planner")


class Planner:
    def __init__(
        self,
        urdf: str,
        planning_group: Sequence[str],
        ee_link_name: str,
        base_pose=None,
        srdf: str = None,
        use_convex=True,
        timestep: float = None,
        joint_vel_limits: Union[float, Sequence[float], np.ndarray] = None,
        joint_acc_limits: Union[float, Sequence[float], np.ndarray] = None,
    ):
        r"""Motion planner for robots.

        Args:
            urdf: path to URDF (Unified Robot Description Format) file.
            planning_group: names of joints to plan. The order of names affects the order of output.
                If the length is zero, all supported joints of end-effector will be used.
            ee_link_name: the end-effector link to plan.
            base_pose (optional): pose of the robot base.
            srdf: path to Semantic Robot Description Format file (SRDF).
                If None, try to replace the extension (*.urdf -> *.srdf).
            use_convex: whether to use convex collision shapes.
                If True, the *.convex.stl (generated by SAPIEN) is used.
            timestep: step for time parameterization. If None, disable time parameterization.
            joint_vel_limits: maximum joint velocities for time parameterization,
                which should have the same length as planning_group. Support broadcast.
            joint_acc_limits: maximum joint accelerations for time parameterization,
                which should have the same length as planning_group. Support broadcast.

        Raises:
            FileNotFoundError: SRDF is not found.

        See also:
            - https://moveit.picknik.ai/humble/doc/concepts/concepts.html
            - https://wiki.ros.org/urdf
            - https://wiki.ros.org/srdf
            - https://github.com/stack-of-tasks/pinocchio
            - https://github.com/humanoid-path-planner/hpp-fcl
            - https://github.com/ompl/ompl
            - https://github.com/hungpham2511/toppra
        """
        self.urdf = urdf
        if not srdf:
            srdf = urdf.replace(".urdf", ".srdf")
            logger.warn("No SRDF provided. Use SRDF at {}.".format(srdf))
        if not os.path.exists(srdf):
            # TODO(jigu): generate SRDF if not exists
            raise FileNotFoundError(srdf)
        self.srdf = srdf

        # Initialize Pinocchio model
        if base_pose is not None:
            base_pose = toSE3(base_pose)
        self.robot = RobotWrapper.loadFromURDF(
            urdf, use_convex=use_convex, base_pose=base_pose
        )
        self.robot.initCollisionPairs()
        self.robot.removeCollisionPairsFromSRDF(srdf)

        # Setup planning interface
        # NOTE(jigu): I assume a single dof per joint here for simpliticy
        self.set_planning_interface(planning_group, ee_link_name)

        # Time parameterization
        self.timestep = timestep
        self.joint_vel_limits = np.broadcast_to(joint_vel_limits, self.dof)
        self.joint_acc_limits = np.broadcast_to(joint_acc_limits, self.dof)

    # -------------------------------------------------------------------------- #
    # Planning interface
    # -------------------------------------------------------------------------- #
    def set_planning_interface(self, planning_group, ee_link_name):
        support_joint_ids = self.robot.get_support_joint_ids(ee_link_name)
        support_group = [self.robot.joint_names[i] for i in support_joint_ids]
        if len(planning_group) == 0:
            planning_group = support_group

        self._planning_group = planning_group
        self._ee_link_name = ee_link_name

        # qmask indicates inactive joints. True for inactive
        self.qmask = np.ones(self.robot.nq, dtype=bool)
        self.name_to_idx_q = {}
        self.qinds = []
        for name in planning_group:
            idx_q = self.robot.joint_idx_q(name)
            nq = self.robot.joint_nq(name)
            if name in support_group:
                self.qmask[idx_q : idx_q + nq] = 0
            self.name_to_idx_q[name] = (idx_q, nq)
            if nq != 1:
                raise NotImplementedError("Only support single DoF joint")
            self.qinds.append(idx_q)

    @property
    def dof(self):
        return len(self._planning_group)

    @property
    def planning_group(self):
        return self._planning_group

    @planning_group.setter
    def planning_group(self, planning_group):
        self.set_planning_interface(planning_group, self._ee_link_name)

    @property
    def ee_link_name(self):
        return self._ee_link_name

    @ee_link_name.setter
    def ee_link_name(self, ee_link_name):
        return self.set_planning_interface(self._planning_group, ee_link_name)

    @property
    def scene(self):
        """Get the planning scene."""
        # We reuse RobotWrapper here. Implement an individual PlanningScene if necessary.
        return self.robot

    # -------------------------------------------------------------------------- #
    # Algorithms
    # -------------------------------------------------------------------------- #
    def compute_CLIK(
        self,
        goal_pose,
        init_qpos,
        max_trials=1,
        check_collision=True,
        seed=None,
        **kwargs
    ):
        """Closed-Loop Inverse Kinematics.

        Args:
            goal_pose: goal pose of end-effector. Refer to `to_SE3` for all supported formats.
            init_qpos: initial joint configuration for optimization.
            max_trials (int, optional): maximum numbers of initial (random) configurations to solve.
                Defaults to 1. If equals to 1, then only init_qpos is tried.
            check_collision (bool, optional): whether to check collision for IK solutions. Defaults to True.
            seed (int, optional): random seed.
            kwargs: hyperparameters for CLIK algorithm

        Returns:
            np.ndarray: [N, nq], IK solutions.
        """
        assert (
            len(init_qpos) == self.robot.nq
        ), "The length of init_qpos({}) is expected to be equal to nq({})".format(
            len(init_qpos), self.robot.nq
        )

        goal_pose = toSE3(goal_pose)
        _init_qpos = np.array(init_qpos)
        results = []

        # NOTE(jigu): do not use pinocchio random configuration since I do not know how to fix random seed.
        state_space = JointStateSpace(*self.robot.joint_limits)
        rng = np.random.RandomState(seed)

        # Modify state space for inactive joints
        state_space.low[self.qmask] = init_qpos[self.qmask]
        state_space.high[self.qmask] = init_qpos[self.qmask]

        for _ in range(max_trials):
            goal_qpos, ik_succ, ik_err = self.robot.compute_CLIK(
                goal_pose, self._ee_link_name, _init_qpos, qmask=self.qmask, **kwargs
            )

            # TODO(jigu): check joint limits

            if ik_succ:
                if check_collision and not self.robot.isCollisionFree(goal_qpos):
                    logger.debug("Find a solution of IK, but not collision-free")
                    ik_succ = False
            else:
                logger.debug("Fail to solve IK. The error is {}".format(ik_err))

            if ik_succ:
                logger.debug("Find a solution of IK")
                results.append(goal_qpos)

            # Try another configuration
            _init_qpos = state_space.sample_uniform(rng)

        return np.array(results).reshape(-1, len(_init_qpos))

    def plan_birrt(
        self,
        goal,
        start_qpos,
        rrt_range=0.1,
        rrt_max_iter=10000,
        seed=None,
        timestep=None,
        goal_fmt="pose",
    ):
        """Plan a path by RRT-Connect (BiRRT).

        Args:
            goal: goal pose of end-effector or goal configuration.
            start_qpos (np.ndarray): start configuration
            rrt_range (float, optional): RRT range. Defaults to 0.1.
                It represents the maximum length of a motion to be added in the tree of motions.
            rrt_max_iter (int, optional): maximum number of trials to expand trees. Defaults to 10000.
            seed: random seed.
            goal_fmt (str, optional): ["pose", "qpos"].

        Returns:
           dict:
            - status (str): success or other failure status
            - reason (str, optional): failure reason
            - position (np.ndarray, optional): [N, nq], found path.

        See also:
            - https://ompl.kavrakilab.org/classompl_1_1geometric_1_1RRTConnect.html
        """
        if goal_fmt == "qpos":
            if np.ndim(goal) == 1:
                goal_qpos = [goal]
            elif np.ndim(goal) == 2:
                goal_qpos = goal
            else:
                raise RuntimeError(np.shape(goal))
        else:
            # TODO(jigu): add options for IK
            goal_qpos = self.compute_CLIK(
                goal,
                start_qpos,
                max_trials=20,
                check_collision=True,
                seed=seed,
            )
            if len(goal_qpos) == 0:
                logger.info("IK_FAILURE: Fail to find a feasible configuration by IK.")
                return {
                    "status": "IK_FAILURE",
                    "reason": "Fail to find a feasible configuration by IK.",
                }

        state_space = JointStateSpace(*self.robot.joint_limits)
        # state_space.set_state_validity_checker(lambda x: True)
        state_space.set_state_validity_checker(self.robot.isCollisionFree)
        goal_space = GoalStates(goal_qpos, state_space, 1e-3)

        # Modify state space for inactive joints
        state_space.low[self.qmask] = start_qpos[self.qmask]
        state_space.high[self.qmask] = start_qpos[self.qmask]

        rrt = RRTConnect(state_space)
        rrt.setup(
            [start_qpos],
            goal_space.goal,
            max_dist=rrt_range,
            max_iter=rrt_max_iter,
            seed=seed,
        )
        path = rrt.solve()

        if rrt.status != "success":
            logger.info("RRT_FAILURE: {}".format(rrt.status))
            result = dict(status="RRT_FAILURE", reason=rrt.status)
            return result

        path = np.array(path)
        path = path[:, self.qinds]
        result = dict(status="success")
        result["position"] = path

        if self.timestep is not None:
            result.update(
                parameterize_path(
                    path, self.joint_vel_limits, self.joint_acc_limits, self.timestep
                )
            )

        return result

    def plan_screw(self, goal_pose, start_qpos, qpos_step=0.1):
        """Plan a path by screw motion.

        Args:
            goal_pose: goal pose of end-effector
            start_qpos: [nq], start configuration
            qpos_step: maximum norm of configuration per step

        Returns:
            dict: same as `plan_by_birrt`
        """
        frame_id = self.robot.frame_index(self._ee_link_name)
        # Current EE pose at base frame
        curr_pose = self.robot.framePlacement(start_qpos, frame_id)
        # Target EE pose at base frame
        goal_pose = self.robot._base_pose.inverse() * toSE3(goal_pose)

        # Spatial twist (screw?)
        delta_pose = goal_pose * curr_pose.inverse()
        residual_screw = np.array(pin.log6(delta_pose))

        qpos = np.array(start_qpos)
        path = [qpos]
        result = {}

        while True:
            J = self.robot.computeFrameJacobianWorld(qpos, frame_id)
            delta_qpos = np.linalg.lstsq(J, residual_screw, rcond=None)[0]

            delta_qnorm = np.linalg.norm(delta_qpos)
            if delta_qnorm > qpos_step:
                delta_qpos = delta_qpos * (qpos_step / delta_qnorm)

            # Is it a twist?
            delta_screw = J @ delta_qpos

            # We assume (skrew) axis is the same for delta and residual twist
            dnorm = np.linalg.norm(delta_screw)
            rnorm = np.linalg.norm(residual_screw)
            # print(delta_screw, residual_screw)
            # print(dnorm, rnorm)

            # Adjust if overshoot
            if dnorm > rnorm:
                ratio = rnorm / dnorm
                delta_qpos = delta_qpos * ratio
                delta_screw = delta_screw * ratio
                result["status"] = "success"

            # Update configuration and residual twist
            qpos = qpos + delta_qpos
            residual_screw = residual_screw - delta_screw

            if self.robot.computeCollisions(qpos):
                result["status"] = "PLAN_FAILURE"
                result["reason"] = "collision"
                break

            # Add next configuration into path
            path.append(qpos)
            if result.get("status") == "success":
                break

        path = np.array(path)
        path = path[:, self.qinds]
        if result["status"] == "success":
            result["position"] = path
            if self.timestep is not None:
                result.update(
                    parameterize_path(
                        path,
                        self.joint_vel_limits,
                        self.joint_acc_limits,
                        self.timestep,
                    )
                )
        else:
            result["position"] = path
        return result


try:
    import toppra as ta
    import toppra.algorithm as algo
    import toppra.constraint as constraint
except ImportError:
    logger.warn(
        "toppra is not installed for time parameterization (`pip install toppra`)."
    )


def parameterize_path(waypoints: np.ndarray, vlims, alims, timestep):
    # https://hungpham2511.github.io/toppra/auto_examples/plot_kinematics.html
    # computing the time-optimal path parametrization for robots subject to kinematic and dynamic constraints
    N, dof = waypoints.shape
    assert dof == len(vlims) == len(alims), (dof, len(vlims), len(alims))

    ss = np.linspace(0, 1, N)
    path = ta.SplineInterpolator(ss, waypoints)
    # If only one value is given, then the bound is [-value, value]
    pc_vel = constraint.JointVelocityConstraint(vlims)
    pc_acc = constraint.JointAccelerationConstraint(alims)

    instance = algo.TOPPRA([pc_vel, pc_acc], path, parametrizer="ParametrizeConstAccel")
    jnt_traj = instance.compute_trajectory()

    T = int(jnt_traj.duration / timestep)
    ts_sample = np.linspace(0, jnt_traj.duration, T)
    qs_sample = jnt_traj(ts_sample)
    qds_sample = jnt_traj(ts_sample, 1)
    qdds_sample = jnt_traj(ts_sample, 2)
    return dict(
        position=qs_sample,
        velocity=qds_sample,
        acceleration=qdds_sample,
        duration=jnt_traj.duration,
        time=ts_sample,
    )
